# ðŸª³ Ciroach Milestone: 2026-01-28

**Focus:** Implement execution guards to handle flaky tests and hung processes.

## 1. Data Model Updates (`models.rs)

Before the runners can act, the `RawStep` needs to understand the new configurations.

- **Add retries:** `Option<u32>` to `RawStep`.
- **Add timeout:** `Option<String>` (e.g., "5m", "30s") to `RawStep.
- Update `Step` (compiled) to store `retries` as an integer and `timeout` as a `std::time::Duration`.

## 2. Timeout Logic (`StepRunner`)

The `StepRunner` needs to be the "enforcer".

- Use `tokio::time::timeout` inside `StepRunner::run`.
- **The Challenge:** If a timeout occurs, ensure the `DockerEngine` is told to kill the container immediately so it doesn't leak.
- Add `StepStatus::TimedOut` to the reporting enum for better UX.

## 3. Retry Logic (`StepRunner` or `StageRunner`?)

- **Decision:** Implement retries inside `StepRunner`. It should loop its `execute` logic based on the `retries` count.
- **Logging:** Ensure the `LogMessage` includes retry attempts (e.g., `[OUT]` `[test-1]` `(Attempt 2/3) Running...`).
- **Success Criteria:** If attempt 1 fails but attempt 2 succeeds, the final `StepReport` should be `Success`.

## 4. Docker Engine Enhancements (`engine.rs`)

- Implement `stop_container` or enhance `force_remove_container` to ensure it can interrupt a container that is actively streaming logs.
- Add a "Cleanup" hook to ensure that on a `SIGINT` (Ctrl+C), all currently running containers are wiped.

## Testing Scenarios

1. **The Infinite Loop:** A step with `command = "while true; do sleep 1; done"` and a `timeout = "5s"`.
2. **The Flaky Success:** A step with `command = "if [ ! -f /tmp/run ]; then touch /tmp/run; exit 1; fi; exit 0"` and `retries = 1`.
