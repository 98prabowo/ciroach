# ü™≥ Ciroach Milestone: 2026-01-27

**Focus:** Concurrency & Resource Hygiene

## 1. The "Clean Room" Initiative (Cleanup)

Before we make things run faster, we must make them cleaner. You need to decide between **Cache** (Speed) and **Cleanliness** (Space).

- **Task 1: The Artifact Wipe.** Implement a flag or a logic gate to handle the `target` folder. Since it's bind-mounted, `ciroach` creates files on your host disk that persist.
- **Task 2: Docker Image Pruning.** Use Bollard's `prune_images` or `remove_image` API. If a user changes an image tag, the old 1.5GB `rust:latest` stays on the disk forever unless you tell Docker to reap it.
- **Task 3: Post-Pipeline Hook.** Ensure the "Cleanup" step in your TOML always runs, even if the "Heavy Build" OOMs or fails.

## 2. The "Swarm" Engine (Parallelism)

This is the biggest architectural shift. You will move from a `for` loop to a Task Pool.

- **Task 1: Dependency Mapping.** Right now, your code assumes Step 1 must finish before Step 2. You'll need to add a `parallel = true` (or similar) field to your TOML struct.
- **Task 2: The `tokio::spawn` Wrapper.** \* Move the "Pull -> Create -> Start -> Log -> Inspect -> Remove" logic into a separate `async fn run_step`.
  - Use `tokio::spawn` to launch multiple of these functions at once.
- **Task 3: The Log Multiplexer. \* The Problem:** If 3 containers print at once, your terminal will be a mess.
  - **The Solution:** Use a `tokio::sync::mpsc` (Multi-Producer, Single-Consumer) channel. Each task sends its log lines to the channel, and one "Master Logger" prints them gracefully.

## üìù Implementation Notes for Tomorrow

#### Key Refactor: The Step Runner

You'll want to move the "nitty-gritty" Bollard code you mastered today into a function like this:

```rust
async fn run_step(step: Step, docker: Docker, tx: Sender<LogLine>) -> anyhow::Result<i32> {
    // tx.send(...) will be used to pipe logs back to the main thread
}
```

#### Resource Risk

Parallelism increases the risk of **OOM (Out of Memory)**.

- If you run three `2gb` steps at once, your runner will try to claim **6GB** of RAM.
- **Strategy:** Implement a "Global Limit" check or a "Semaphore" to limit the number of concurrent containers (e.g., only 2 at a time).

## üõ† Tomorrow's First Step

When you start tomorrow, the first thing we should do is **refactor the loop**. We need to take that massive `main` function and break it into smaller, "spawnable" pieces.
